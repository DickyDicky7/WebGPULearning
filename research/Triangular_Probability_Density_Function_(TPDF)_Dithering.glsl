    // --- 1. Pseudo-Random Number Generator ---
//  // --- 1. Pseudo-Random Number Generator ---
    // Standard "Gold Noise" or similar hash to get random values per pixel
//  // Standard "Gold Noise" or similar hash to get random values per pixel
    float hash12(vec2 p) {
//  float hash12(vec2 p) {

        vec3 p3  = fract(vec3(p.xyx) * .1031);
//      vec3 p3  = fract(vec3(p.xyx) * .1031);
        p3 += dot(p3, p3.yzx + 33.33);
//      p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
//      return fract((p3.x + p3.y) * p3.z);

    }
//  }

    // --- 2. Triangular Noise Function ---
//  // --- 2. Triangular Noise Function ---
    // TPDF is generated by adding two independent uniform random variables.
//  // TPDF is generated by adding two independent uniform random variables.
    // Input: uv coordinates (to seed the random generator)
//  // Input: uv coordinates (to seed the random generator)
    // Output: Noise value in range [-1.0, 1.0] with a triangular distribution
//  // Output: Noise value in range [-1.0, 1.0] with a triangular distribution
    float triangularNoise(vec2 uv) {
//  float triangularNoise(vec2 uv) {

        // We need two independent seeds.
//      // We need two independent seeds.
        // We can offset the coordinates slightly to get a second independent value.
//      // We can offset the coordinates slightly to get a second independent value.
        float r1 = hash12(uv);
//      float r1 = hash12(uv);
        float r2 = hash12(uv + vec2(1.0, 1.0)); // Slight offset for independence
//      float r2 = hash12(uv + vec2(1.0, 1.0)); // Slight offset for independence

        // Sum of two rectangular distributions (0..1) minus 1.0
//      // Sum of two rectangular distributions (0..1) minus 1.0
        // Result is centered at 0.0, spanning -1.0 to 1.0
//      // Result is centered at 0.0, spanning -1.0 to 1.0
        return r1 + r2 - 1.0;
//      return r1 + r2 - 1.0;

    }
//  }

    void mainImage( out vec4 fragColor, in vec2 fragCoord )
//  void mainImage( out vec4 fragColor, in vec2 fragCoord )
    {
//  {
        // Normalized pixel coordinates (from 0 to 1)
//      // Normalized pixel coordinates (from 0 to 1)
        vec2 uv = fragCoord/iResolution.xy;
//      vec2 uv = fragCoord/iResolution.xy;

        // --- Generate a Gradient for Demonstration ---
//      // --- Generate a Gradient for Demonstration ---
        // A smooth gradient that would normally show banding at low bit depths
//      // A smooth gradient that would normally show banding at low bit depths
        vec3 col = vec3(uv.x);
//      vec3 col = vec3(uv.x);

        // --- Dithering Configuration ---
//      // --- Dithering Configuration ---
        // Number of color levels (e.g., 4.0 for a retro look, 255.0 for standard 8-bit)
//      // Number of color levels (e.g., 4.0 for a retro look, 255.0 for standard 8-bit)
        float levels = 16.0;
//      float levels = 16.0;

        // --- Apply Triangular Dithering ---
//      // --- Apply Triangular Dithering ---
        // 1. Generate triangular noise in [-1, 1]
//      // 1. Generate triangular noise in [-1, 1]
        float noise = triangularNoise(fragCoord);
//      float noise = triangularNoise(fragCoord);

        // 2. Scale noise to the size of one quantization step (1 LSB)
//      // 2. Scale noise to the size of one quantization step (1 LSB)
        // TPDF standard practice is 2 LSB peak-to-peak (-1 to +1 LSB).
//      // TPDF standard practice is 2 LSB peak-to-peak (-1 to +1 LSB).
        float ditherShift = noise / levels;
//      float ditherShift = noise / levels;

        // 3. Add noise to the original signal
//      // 3. Add noise to the original signal
        vec3 ditheredCol = col + ditherShift;
//      vec3 ditheredCol = col + ditherShift;

        // 4. Quantize (Round to nearest level)
//      // 4. Quantize (Round to nearest level)
        ditheredCol = floor(ditheredCol * levels + 0.5) / levels;
//      ditheredCol = floor(ditheredCol * levels + 0.5) / levels;

        // --- Comparison Split Screen ---
//      // --- Comparison Split Screen ---
        // Left side: Dithered | Right side: Quantized without Dither (Banding)
//      // Left side: Dithered | Right side: Quantized without Dither (Banding)
        if (uv.y < 0.5) {
//      if (uv.y < 0.5) {
            // Standard quantization (showing bands)
//          // Standard quantization (showing bands)
            vec3 undithered = floor(col * levels + 0.5) / levels;
//          vec3 undithered = floor(col * levels + 0.5) / levels;
            fragColor = vec4(undithered, 1.0);
//          fragColor = vec4(undithered, 1.0);
        } else {
//      } else {
            // Triangular Dithered
//          // Triangular Dithered
            fragColor = vec4(ditheredCol, 1.0);
//          fragColor = vec4(ditheredCol, 1.0);
        }
//      }

        // Add a black line to separate the views
//      // Add a black line to separate the views
        if(abs(uv.y - 0.5) < 0.002) fragColor = vec4(0.0);
//      if(abs(uv.y - 0.5) < 0.002) fragColor = vec4(0.0);
    }
//  }
